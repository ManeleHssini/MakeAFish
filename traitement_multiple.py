# -*- coding: utf-8 -*-
"""traitement_multiple.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g_i8jCS7zu9xqfQbY-xFAD-k3Y0HH44e
"""

# traitement_multiple.py

import os
import zipfile
import tempfile # Import added for tempfile.mkdtemp() and shutil.rmtree()
import shutil # Import added for shutil.rmtree()

# Assurez-vous que fusion_intelligente_avec_photo est correctement importée
# ou définie dans 'traitement.py' et accessible ici.
from traitement import fusion_intelligente_avec_photo

def lister_fichiers(dossier_path, extensions):
    """
    Liste les fichiers dans un dossier avec les extensions spécifiées,
    retourne les noms de base sans extension.
    Prend un CHEMIN DE DOSSIER (string) en entrée.
    """
    noms_base = set()
    # Vérifier que le dossier_path est bien une chaîne de caractères et qu'il existe
    if isinstance(dossier_path, str) and os.path.isdir(dossier_path):
        for filename in os.listdir(dossier_path):
            nom, ext = os.path.splitext(filename)
            if ext.lower() in extensions:
                noms_base.add(nom)
    else:
        # Ceci est un message d'erreur crucial si lister_fichiers ne reçoit pas un chemin valide
        print(f"Erreur: lister_fichiers a reçu un chemin invalide ou inexistant: {dossier_path}")
    return noms_base

def traitement_par_batch(dossier_fiches_pdf, dossier_photos, modele_path):
    """
    Traite un lot de fiches PDF et de photos, les fusionne
    et crée un fichier ZIP des résultats.
    Prend des CHEMINS DE DOSSIERS (strings) en entrée.
    """
    output_temp_dir = None # Initialise pour le bloc finally
    try:
        output_temp_dir = tempfile.mkdtemp() # Créer un répertoire temporaire pour les PDF fusionnés

        # Appel de lister_fichiers avec les chemins de dossiers (strings)
        noms_fiches = lister_fichiers(dossier_fiches_pdf, ['.pdf'])
        noms_photos = lister_fichiers(dossier_photos, ['.jpg', '.jpeg', '.png', '.pdf'])

        correspondances = noms_fiches.intersection(noms_photos)

        if not correspondances:
            print("Aucune correspondance trouvée pour le traitement par lot dans traitement_multiple.py.")
            return None

        # Crée le fichier ZIP dans le répertoire de travail courant de Streamlit
        zip_filename = os.path.join(os.getcwd(), "fiches_sanitaires_fusionnees.zip")

        # S'assurer que le fichier ZIP peut être créé (écraser l'ancien si nécessaire)
        if os.path.exists(zip_filename):
            os.remove(zip_filename)

        with zipfile.ZipFile(zip_filename, 'w') as zf:
            for nom_base in correspondances:
                fiche_path = os.path.join(dossier_fiches_pdf, f"{nom_base}.pdf")

                photo_path = None
                # Trouver l'extension correcte de la photo
                for ext in ['.jpg', '.jpeg', '.png', '.pdf']:
                    potential_photo_path = os.path.join(dossier_photos, f"{nom_base}{ext}")
                    if os.path.exists(potential_photo_path):
                        photo_path = potential_photo_path
                        break

                if photo_path and os.path.exists(fiche_path): # Vérifier que les deux fichiers existent
                    output_pdf_name = f"fiche_fusionnee_{nom_base}.pdf"
                    output_pdf_path = os.path.join(output_temp_dir, output_pdf_name) # Chemin dans le dossier temp

                    try:
                        # Assurez-vous que fusion_intelligente_avec_photo accepte et gère correctement les chemins absolus
                        fusion_intelligente_avec_photo(fiche_path, modele_path, photo_path, output_pdf_path)
                        zf.write(output_pdf_path, os.path.basename(output_pdf_path)) # Ajouter au ZIP
                    except Exception as e:
                        print(f"Erreur lors de la fusion de {nom_base} : {e}")
                else:
                    if not os.path.exists(fiche_path):
                        print(f"Avertissement: Fiche PDF non trouvée pour '{nom_base}.pdf' à l'emplacement: {fiche_path}")
                    if not photo_path:
                        print(f"Avertissement: Photo non trouvée pour '{nom_base}' (extensions .jpg, .jpeg, .png, .pdf) dans le dossier: {dossier_photos}")

        return zip_filename if os.path.exists(zip_filename) and os.path.getsize(zip_filename) > 0 else None

    except Exception as e:
        print(f"Erreur globale dans traitement_par_batch : {e}")
        return None
    finally:
        if output_temp_dir and os.path.exists(output_temp_dir):
            try:
                shutil.rmtree(output_temp_dir)
            except Exception as e:
                print(f"Impossible de nettoyer le répertoire temporaire {output_temp_dir}: {e}")